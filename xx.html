<script type="text/javascript">
const css=`
// xxx
.aa{
  h1{
    color: #f00;
  }
  .b, .c{
    color: #00f; // }
  }
  &.e, &.f{
    color: #0f0;
  }
  &:after{
    content: '>';
    color: #0f0;
    display: block;
  }
}
.bb{
  font-weight: bold;
}
`

/*
const tokens=[
  {type: T_COMMENT, payload: ' xxx'},
  {type: T_SELECTOR, payload: '.aa', children: [
    {type: T_SELECTOR, payload: '.h1', children: [
      {type: T_RULES, payload: 'color: #f00;'},
    ]},
    {type: T_SELECTOR, payload: '.b, .c', children: [
      {type: T_RULES, payload: 'color: #00f; '},
      {type: T_COMMENT, payload: ' }'},
    ]},
    ...
  ]},
  ...
]
*/

const T_EMPTY='T_EMPTY'
const T_COMMENT='T_COMMENT'
const T_SELECTOR='T_SELECTOR'
const T_SELECTOR_END='T_SELECTOR_END'
const T_RULES='T_RULES'

function lexer(css) {
  function empty(parent) {
    return {type: T_EMPTY, payload: '', children: [], parent}
  }
  let tokens={parent: null, children: []}, c=empty(tokens), i=0
  tokens.children.push(c)
  function moveNext(newChild=false) {
    c=empty(newChild? c: c.parent)
    c.parent.children.push(c)
  }
  function skipSpace() {
    for(; [' ', '\r', '\n'].includes(css[i]); i++);
  }
  function addComment() {
    skipSpace()
    if(css.substr(i, 2)!=='//') return;
    c.type=T_COMMENT
    i+=2
    for(; !['\n', '\r'].includes(css[i]); i++) c.payload+=css[i]
    moveNext()
  }
  function addSelector() {
    skipSpace()
    c.type=T_SELECTOR
    for(; css[i]!=='{'; i++) c.payload+=css[i]
    moveNext(true)
    i++
  }
  function addRules() {
    skipSpace()
    c.type=T_RULES
    for(; css[i]!==';'; i++) c.payload+=css[i]
    c.payload+=';'
    moveNext()
    i++
  }
  function closeSelector() {
    i++
    c=c.parent
    moveNext()
  }
  function getNextToken() {
    skipSpace()
    const [z, t]=[
      [css.indexOf('{', i), T_SELECTOR],
      [css.indexOf('//', i), T_COMMENT],
      [css.indexOf(';', i), T_RULES],
      [css.indexOf('}', i), T_SELECTOR_END],
    ].filter(x=>x[0]!==-1).reduce((a, b)=>a[0]<b[0] && a[0]!==-1? a: b, [-1, T_EMPTY])
    return z===-1? T_EMPTY: t
  }
  function addNextToken() {
    for(let p; p=getNextToken(); ) {
      if(p===T_SELECTOR) addSelector()
      else if(p===T_COMMENT) addComment()
      else if(p===T_RULES) addRules()
      else if(p===T_SELECTOR_END) closeSelector()
      else if(p===T_EMPTY) return
    }
    addNextToken()
  }
  addNextToken()
  return tokens
}
function parser(tokens) {
  const {parent, children}=tokens
  function concat(c) {
    const {payload, parent}=c
    console.log('::', payload, parent.payload)
    const f=c=>c? c.split(',').map(x=>x.trim()).filter(Boolean): null
    return f(payload).map(x=>{
      x=x[0]==='&'? x.substr(1): (' '+x)
      const r=f(parent.payload)
      return r? r.map(p=>p+x).join(','): x
    }).join(',')
  }
  for(let c of children) {
    if([T_COMMENT, T_EMPTY, T_RULES].includes(c.type)) continue
    if(c.type===T_SELECTOR) {
      const cssRules=[]
      const selectors=concat(c)
      for(let cc of c.children) {
        if(cc.type===T_RULES) cssRules.push(cc.payload)
      }
      parser(c)
      console.log(">>", {selectors, cssRules})
    }
  }
}

const tokens=lexer(css)
console.log(parser(tokens))

</script>
